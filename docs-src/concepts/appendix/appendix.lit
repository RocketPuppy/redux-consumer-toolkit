@title Appendix

@s Library Entry-point

I need to define an entry-point file for the library so that NPM can package it
properly.

I want the library to be usable by importing specific modules to aid in
self-documenting code. I need to import everything first

--- import-list
@{import-functor}
@{import-apply}
@{import-applicative}
@{import-profunctor}
@{import-chain}
@{import-monoid}
@{import-semigroup}
---

The export list is just every individual module and a hand-selected list of
methods that are easiest to use.

--- export-list
export {
  Functor,
  Apply,
  Applicative,
  Profunctor,
  Chain,
  Monoid,
  Semigroup,
  map,
  apAll,
  of,
  promap,
  mapIn,
  objectify,
  chain,
  expandAll,
  combine,
  identity,
  concat
};
---

I need to extract all the methods for the named exports

--- index.js ---
@{import-list}

const { map } = Functor;
const { apAll } = Apply;
const { of } = Applicative;
const { promap, mapIn, objectify } = Profunctor;
const { chain, expandAll, combine } = Chain;
const { identity } = Monoid;
const { concat } = Semigroup;

@{export-list}
---

@s Memoization

It is sometimes useful to have the combinators exported by this library be
memoized to avoid recomputing values that haven't changed. To that end a
memoized version of each function is setup here. It currently relies on the
memoize function from the ramda library. Note that Monoid does not need
memoizing since it is memoized by its implementation. I also need to import the
modules under a different name in order to re-export them properly.

--- memoized.js
import memoize from 'ramda/src/memoize.js';
import FunctorI from './Functor';
import ApplyI from './Apply';
import ApplicativeI from './Applicative';
import ChainI from './Chain';
import ProfunctorI from './Profunctor';
import SemigroupI from './Semigroup';
@{import-monoid}

let { map } = FunctorI;
let { ap, apAll } = ApplyI;
let { of } = ApplicativeI;
let { promap, mapIn, mapOut, objectify } = ProfunctorI;
let { bind, chain, expand, expandAll, combine } = ChainI;
let { concat } = SemigroupI;
const { identity } = Monoid;

map = memoize(map);
ap = memoize(ap);
apAll = memoize(apAll);
of = memoize(of);
promap = memoize(promap);
mapIn = memoize(mapIn);
mapOut = memoize(mapOut);
objectify = memoize(objectify);
bind = memoize(bind);
chain = memoize(chain);
expand = memoize(expand);
expandAll = memoize(expandAll);
combine = memoize(combine);
concat = memoize(concat);

const Functor = {
  map
};

const Apply = {
  ap,
  apAll
};

const Applicative = {
  of
};

const Profunctor = {
  promap,
  mapIn,
  mapOut,
  objectify
};

const Chain = {
  bind,
  chain,
  expand,
  expandAll,
  combine
};

const Semigroup = {
  concat
};

@{export-list}
---

@s Utility Functions

I use a version of function composition throughout the examples. It is defined as follows.

--- compose
const compose = (f, g) => (...args) => f(g(...args))
---

The constant function is mentioned occasionally. It is defined with a type signature as follows.

--- constant
type Constant<A, B> = (a) => (b) => a
const constant : Constant<*,*> = x => y => x
---

The identity function is a useful function and appears in some of the laws for the interfaces.

--- identity
const identity = (x) => x
---

The filter function is used in some examples

--- filter
const filter = (f, c) => (
  c.reduce((memo, x) => (
    f(x) ? memo.concat(x) : memo
  ), [])
);
---
